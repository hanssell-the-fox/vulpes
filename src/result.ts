// result.ts

/**
 * Represents the *outcome* of some operation that ended in success (`Ok`) or a failure (`Err`).
 *
 * @template T Type of the success value.
 * @template E Type of the error value.
 */
export abstract class Result<T, E> {
  /**
   * An `Ok` value.
   *
   * @param value - The value to represent a success.
   * @returns An instance of Result containing a success value.
   */
  public static Ok<T>(value: T): Result<T, never> {
    return new Ok(value);
  }

  /**
   * An `Error` value.
   *
   * @param value - The value to represent an error.
   * @returns An instance of Result containing an error value.
   */
  public static Err<T>(value: T): Result<never, T> {
    return new Err(value);
  }

  /**
   * Checks if it is a success.
   *
   * @returns `true` if it is `Ok`, otherwise `false`.
   */
  public isOk(): this is Result<T, never> {
    return this instanceof Ok;
  }

  /**
   * Checks if it is a failure.
   *
   * @returns `true` if it is `Err`, otherwise `false`.
   */
  public isErr(): this is Result<never, T> {
    return this instanceof Err;
  }

  /**
   * Applies `fn` to the contained value (if `Ok`), and returns the result as an `Ok`.
   *
   * @param fn - Function to apply to the contained success value.
   * @returns A new `Ok` containing the result of the function.
   */
  public map<U>(fn: (value: T) => U): Result<U, E> {
    if (this.isErr()) return this as unknown as Result<U, E>;
    return Result.Ok(fn(this.unwrap()));
  }

  /**
   * Applies `fn` to the contained error value (if `Err`), and returns the result as an `Err`.
   *
   * @param fn - Function to apply to the contained error value.
   * @returns A new `Err` containing the result of the function.
   */
  public mapErr<U>(fn: (value: E) => U): Result<T, U> {
    if (this.isOk()) return this as unknown as Result<T, U>;
    return Result.Err(fn(this.unwrapErr()));
  }

  /**
   * Matches the type of the Result and executes the apropriate *handler* function.
   *
   * @param handlers - Object containing functions to be called on each variant of `Result`.
   * @returns Any value generated by the executed handler.
   */
  public abstract match<U>({ Ok, Err }: { Ok: (value: T) => U; Err: (value: E) => U }): U;

  /**
   * Returns the contained success value or the provided *default* if it is an error.
   *
   * @param defaultValue - Value to be used in case of Err.
   * @returns The contained success value or the default.
   */
  public or(defaultValue: T): T {
    return this.match({
      Ok: (value: T) => value,
      Err: () => defaultValue,
    });
  }

  /**
   * Returns the contained success value or throws an exception if `Err`.
   *
   * @returns The contained success value.
   */
  public abstract unwrap(): T;

  /**
   * Returns the contained error value or throws an exception if `Ok`.
   *
   * @returns The contained error value.
   */
  public abstract unwrapErr(): E;
}

/**
 * Variant of `Result` that contains a success value.
 *
 * @template T Type of the contained success value.
 */
class Ok<T> extends Result<T, never> {
  public constructor(private readonly value: T) {
    super();
  }

  /** @inheritdoc */
  public override match<U>({ Ok: handler }: { Ok: (value: T) => U }): U {
    return handler.call(this, this.value);
  }

  /** @inheritdoc */
  public override unwrap(): T {
    return this.value;
  }

  /** @inheritdoc */
  public override unwrapErr(): never {
    throw new TypeError("Trying to get an error from Ok");
  }
}

/**
 * Variant of `Result` that contains an error value.
 *
 * @template T Type of the contained error value.
 */
class Err<T> extends Result<never, T> {
  public constructor(private readonly value: T) {
    super();
  }

  /** @inheritdoc */
  public override match<U>({ Err: handler }: { Err: (value: T) => U }): U {
    return handler.call(this, this.value);
  }

  /** @inheritdoc */
  public override unwrap(): never {
    throw new TypeError("Trying to unwrap Err");
  }

  /** @inheritdoc */
  public override unwrapErr(): T {
    return this.value;
  }
}

/** @inheritdoc */
const ok: typeof Result.Ok = Result.Ok;

/** @inheritdoc */
const err: typeof Result.Err = Result.Err;

export { err as Err, ok as Ok };
