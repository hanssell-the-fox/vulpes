// option.ts

/**
 * Represents a value that may be present (`Some`) or absent (`None`).
 *
 * @template T Type of the value.
 */
export abstract class Option<T> {
  /**
   * Some value.
   *
   * @template T Type of the value
   * @returns An Option containing a value.
   */
  public static Some<T>(value: NonNullable<T>): Option<NonNullable<T>> {
    return new Some(value);
  }

  /**
   * No value.
   */
  public static None(): Option<never> {
    return new None();
  }

  /**
   * Creates an `Option` from a "nullable" value, returns `None` if `null`/`undefined`, `Some` otherwise.
   *
   * @template T Type of the value.
   * @returns `Some` with the value or `None` if nullable.
   */
  public static from<T>(value: T): Option<NonNullable<T>> {
    return value == null ? Option.None() : Option.Some(value as NonNullable<T>);
  }

  /**
   * Checks if it has a value.
   *
   * @returns `true` if it contains a value, `false` otherwise.
   */
  public isSome(): this is Option<NonNullable<T>> {
    return this instanceof Some;
  }

  /**
   * Checks if it is empty.
   *
   * @returns `true` if it is empty, `false` otherwise.
   */
  public isNone(): this is Option<never> {
    return this instanceof None;
  }

  /**
   * Applies `fn` to the value (if `Some`), and returns a new `Some` containing the result.
   *
   * @param fn - Function to apply to the contained value.
   * @returns A new Option of type Some containing the result of the function.
   */
  public map<U>(fn: (value: NonNullable<T>) => U): Option<NonNullable<U>> {
    if (this.isNone()) return this;
    return Option.from(fn(this.unwrap()));
  }

  /**
   * Matches the type of the Option and executes the apropriate *handler* function.
   *
   * @param handlers - Object containing functions to be called on each variant of `Option`.
   * @returns Any value generated by the executed handler.
   */
  public abstract match<U>({ Some, None }: { Some: (value: NonNullable<T>) => U; None: () => U }): U;

  /**
   * Returns the contained value or the provided *default* if it is empty.
   *
   * @param defaultValue - Value to be used in case of None.
   * @returns The contained success value or the default.
   */
  public or(defaultValue: NonNullable<T>): NonNullable<T> {
    return this.match({
      Some: (value) => value,
      None: () => defaultValue,
    });
  }

  /**
   * Returns the contained value or throws an exception if `None`.
   *
   * @returns The contained value.
   */
  public abstract unwrap(): NonNullable<T>;
}

/**
 * Variant of Option that contains a value.
 */
class Some<T> extends Option<T> {
  public constructor(private readonly value: NonNullable<T>) {
    super();
  }

  /** @inheritdoc */
  public override match<U>({ Some: handler }: { Some: (value: NonNullable<T>) => U }): U {
    return handler.call(this, this.value);
  }

  /** @inheritdoc */
  public override unwrap(): NonNullable<T> {
    return this.value;
  }
}

/**
 * Variant of Option that is empty.
 */
class None extends Option<never> {
  // Singleton
  private static instance: None = new None();

  public constructor() {
    if (None.instance) return None.instance;
    super();
  }

  /** @inheritdoc */
  public override match<U>({ None: handler }: { None: () => U }): U {
    return handler.call(this);
  }

  /** @inheritdoc */
  public override unwrap(): never {
    throw new TypeError("Trying to unwrap None");
  }
}

/** @inheritdoc */
const some: typeof Option.Some = Option.Some;

/**
 * No value.
 */
const none: Option<never> = Option.None();

export { none as None, some as Some };
